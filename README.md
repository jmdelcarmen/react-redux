# Modern React-Redux

## Tips for writing React Components
  * Passing down a callback to child components is good for changing the state of the parent component.
  * Use Conditional rendering when component is relying on props/state.
  * When defining callbacks on event-handlers, don't forget to bind the context of 'this'
  ```js
  onInputChange(event) {
    this.setState({ term: event.target.value });
  }

  render() {
    return (
      <form className="input-group">
        <input
          value={this.state.term}
          onChange={this.onInputChange.bind(this)}
          placeholder="Get a five-day forecast in your favorite cities"
          className="form-control" />
        );
      }
  ```

## What is Redux?
  * Redux contains the application state, which is generated by a series of **reducers**, that state is then modified by calling action creators.
  * **Reducer** - function that returns the App's state. Produces the value of the state. When a new value of state is produced, the reducers re-render the containers.
  * **Action Creators** - return actions which flow through middleware(redux-promise), then into all the reducers that care about that certain action type.

---
## Notes:
1. Connecting Redux to Container Component/Smart Component
  - Put the component that is most reliant on the app state inside the container directory.
  - in that component, ``import { connect } from 'react-redux'``.
  - similarly, if that container is reliant on an action-creator, ``import { bindActionCreators } from 'redux';``
    as well as importing the certain action-creator ``import { action } from ../folder/action/action;``

**Application State**
  - Located in the reducers directory
  - all reducers get tied together with the combineReducers method from redux

  ```js
  import { combineReducers } from 'redux';
  import BooksReducer from './reducer_books';
  import ActiveBook from './reducer_active_book';

  //mapping of state
  const rootReducer = combineReducers({
    books: BooksReducer,
    activeBook: ActiveBook
  });

  export default rootReducer;
  ```

  - in a container create a function that takes state as a parameter
  ```js
  function mapStateToProps(state) {
      //Whatever is returned will show up as props in
      //this component
      return {
        books: state.books
      };
    }
    //mapStateToProps is called when state changes
    //this container is located in the containers dir.
    export default connect(mapStateToProps)(BookList);
  ```
---
2. **Action Creators** - function that returns an action
  - an action is just a plain JS object with a type property
  - in the actions directory, create a function that returns an action.
  - in the container, `import { actioh } from '../action/action'`;
  - and which makes this action available as ***props*** `import { bindActionCreators } from 'redux';`

  - create the **action**
  ```js
  'use strict';
  //action
  export const BOOK_SELECTED = 'BOOK_SELECTED';
  export function selectBook(book) {
    //selectBook is an action Creator
    //it needs to return an action, an object with a type property
    return {
      type: BOOK_SELECTED,
      payload: book
    };
  }
  ```

**Update the export of the container**
  ```js
  'use strict';

  import React, { Component } from 'react';
  import { connect } from 'react-redux';
  import { selectBook } from '../actions/index';
  import { bindActionCreators } from 'redux';

  class BookList extends Component {
    renderList() {
      return this.props.books.map((book) => {
        return (
          <li
           key={book.title}
           //bind action(selectBook) to each list-item's click handler
           onClick={() => this.props.selectBook(book)}
           className="list-group-item">{book.title}
           </li>
        );
      });
    }

    render() {
      return (
        <ul className="col-sm-4 list-group">
          {this.renderList()}
        </ul>
      )
    }
  }

  function mapStateToProps(state) {
    //whatever is returned will show up as props
    //in this container
    return {
      books: state.books
    };
  }

  //any action returned from this function will end up as
  //props in this container
  function mapDispatchToProps(dispatch) {
    //whenever selectBook is called, result should map
    //to all reducers
    return bindActionCreators({ selectBook }, dispatch);
  }

  //promote booklist from a component to a container
  //it needs to know about this new dispatch method, selectBook
  //available as props
  export default connect(mapStateToProps, mapDispatchToProps)(BookList);
  ```

  - The **reducer** that will catch the action when each list-item is clicked.

  ```js
  'use strict';
  //state argument is not application state,
  //only state of this container
  import { BOOK_SELECTED } from '../action/action';
  //using BOOK_SELECTED variable here to limit typo
  export default function(state = null, action) {
    switch(action.type) {
      case BOOK_SELECTED:
        return action.payload;
    }
    return state;
  }
  ```
---

3. Creating an action and connecting it to redux
  - create an action/function that simply returns an object with **type** as a property
  - **reducers** are responsible for manipulating the Application state through the use of **actions**
  ```js
  export function action(item) {
    return {
      type: action_type,
      payload: item
    }
  }
  ```

  - each reducer has the option to return a different piece of state depending on the **type of the action** received
  - in a reducer that cares about this action. Create a switch/case statement
  ```js
  export default function (state = null, action) {
    switch(action.type) {
      //some_response will be set to the state of this container
      case action_type1:
        return some_response1;
      case action_type2:
        return some_response2;
    }
    return state;
  }
  ```

  - in the container responsible for this piece of state import the following, and export accordingly

  ```js
  import React, { Component } from 'react';
  import { connect } from 'react-redux';
  import { bindActionCreators } from 'redux';
  import { action } from '../actions/action';

  class ..... {
    render() {
      return (
        //calls the action below
        <button onClick={() => this.props.action()}>
          Call action.
        </button>
      );
    }
  }

  function mapStateToProps(state) {
    return {
      state: state.value
    }
  }

  function mapDispatchToProps(dispatch) {
    return bindActionCreators({ action: action }, dispatch);
  }

  export default connect(mapStateToProps, mapDispatchToProps)(Message);

  //OR you could remove the mapDispatchToProps method and just do this

  export default connect(mapStateToProps, { action })(Message);

  ```

---

4. Making HTTP requests with Axios in action creators
  - after installing axios ``$ npm i -S axios``
  - example weather request
  ```js
  'use strict';

  import axios from 'axios';

  const API_KEY = '';
  //action type
  export const FETCH_WEATHER = 'FETCH_WEATHER';

  export function fetchWeather(city) {
    const urlString = `http://api.openweathermap.org/data/2.5/forecast?q=${city}&appid=${API_KEY}`;
    const request = axios.get(urlString);
    return {
      type: FETCH_WEATHER,
      payload: request
    };
  }
  ```
  ---

  5. Connecting React and Redux in ``index.js``
  ```js

  'use strict';
  import React from 'react';
  import { render } from 'react-dom';
  import { Provider } from 'react-redux';
  import { createStore, applyMiddleware } from 'redux';
  import ReduxPromise from 'redux-promise';

  import App from './components/app';
  import reducers from './reducers'; //import directory with all reducers

  const createStoreWithMiddleware = applyMiddleware(ReduxPromise)(createStore);

  render(
    <Provider store={createStoreWithMiddleware(reducers)}>
      <App />
    </Provider>
    , document.querySelector('.container'));
  ```
---
6. Using React-Router
  - install react-router then ``import { Router, browserHistory } from 'react-routes';``
  - create a separate routes.js file where your routes will be

  ```js
  'use strict';

  import React from 'react';
  import { Route } from 'react-router';

  import App from './components/app';

  export default (
    <Route path="/" component={App} />
  );

  ```

  - import routes into main server directory and connect route to the Router component

  ```js
  'use strict';

  import React from 'react';
  import { render } from 'react-dom';
  import { Provider } from 'react-redux';
  import { createStore, applyMiddleware } from 'redux';
  import { Router, browserHistory } from 'react-router';
  import reducers from './reducers';

  //routes
  import Routes from './routes';

  const createStoreWithMiddleware = applyMiddleware()(createStore);

  render(
    <Provider store={createStoreWithMiddleware(reducers)}>
      <Router history={browserHistory} routes={Routes} />
    </Provider>
    , document.querySelector('.container'));
  ```

  - when dealing with nested routes ``app.js``

  ```js
  import React, { Component } from 'react';

  export default class App extends Component {
    render() {
      return (
        <div>
        React simple starter
        {this.props.children} //renders nested routes
        </div>
      );
    }
  }
  ```
---
7. Redux-Form
  - install redux-form ``npm i -S redux-form`` to watch the form component
  - ``import { reducer as formReducer } from 'redux-form';`` in the main reducer file, then set ``state.form: formReducer``

  ```js
  import { combineReducers } from 'redux';

  //reducers
  import PostsReducer from './reducer_posts';
  import { reducer as formReducer } from 'redux-form';

  const rootReducer = combineReducers({
    posts: PostsReducer,
    form: formReducer
  });

  export default rootReducer;
  ```

  - in form component, ``import { reduxForm } from 'redux-form';``
  - use ES6 destructuring on this.props to retrieve the fields, and handleSubmit method, then bind handleSubmit to the onSubmit event-handler of the form

  ```js
  'use strict';

  import React, { Component } from 'react';
  import { reduxForm } from 'redux-form';

  class PostsNew extends Component {
    render() {
      const { fields: { title, categories, content }, handleSumbit } = this.props;

      return (
        <form onSubmit={handleSumbit}>
          <h3>Create A New Post</h3>
          <div className="form-group">
            <label>Title</label>
            <input type="text" className="form-control" {...title}/>
          </div>
          <div className="form-group">
            <label>Categories</label>
            <input type="text" className="form-control" {...cateories}/>
          </div>
          <div className="form-group">
            <label>Content</label>
            <textarea className="form-control" {...content}></textarea>
          </div>

          <button className="btn btn-primary">Submit</button>
        </form>
      );
    }
  }

  export default reduxForm({
    form: 'PostsNew', //does not have to match the component
    fields: [ 'title', 'categories', 'content' ],
  })(PostsNew);


  //as a result of these 2 steps, this is what happens in the background
  state === {
    form: {
      PostsNew: {
        title: '...',
        categories: '....',
        content: '...'
      }
    }
  }
  ```
  - in order to submit the form, pass an action-creator to the ``handleSumbit``.
  - create an action-creator

  ```js
  export function createPost(props) { //{ title, categories, content } === props
   const request = axios.post(`${ROOT_URL}/posts/${API_KEY}`, props); //pass props as 2nd argument
    return {
     type: CREATE_POST,
     payload: request
    }
  }
  ```

  - import action-creator

  ```js
  import { createPost } from '../actions/index';

  class ... {
    render() {
      return (
        <form onSubmit={handleSumbit(this.props.createPost)}>
      );
    }
  }


  //connect - (mapStateToProps, mapDispatchToProps)
  //reduxForm - (formConfig = {}, mapStateToProps, mapDispatchToProps) <-- ergo
  export default reduxForm({
    form: 'PostsNew', //does not have to match the component
    fields: [ 'title', 'categories', 'content' ], //defining this array injects each element into the props object.
  }, null, { createPost })(PostsNew);
  ```

  - adding form-validation
  - create a function in component
  - add to form config

  ```js
  function validate(values) {
    const errors = {};

    if (!values.title) {
      errors.title = 'Enter a username'; //if errors object contains any key that matches the elements in the fields, it will prevent form submission.
    }

    return errors;
  }

  export default reduxForm({
    form: 'PostsNew',
    fields: [ 'title', 'categories', 'content' ],
    validate //validation function
  }, null, { createPost })(PostsNew);


  ```
---

8. Redux Thunk

- in an ``actions/index.js`` vanilla redux expects a plain js object with a type prop
- redux-thunk expects a plain js function

```js
import axios from 'axios';

export function fetchUsers() {
  const request = axios.get('http://jsonplaceholder.typicode.com/users');

  return (dispatch) => { //dispatch is basically a funnel that distributes this action to all reducers
    request.then(({ data }) => {
      dispatch({ type: 'FETCH_PROFILES', payload: data });
    })
  };
}
```
---

# Advanced React-Redux

1. **Testing**
- use ``describe`` to group together similar tests
- use ``it`` to test a single attribute of a target
- use ``expect`` to make an assertion about a target
- Assertion-Matchers
  - how to compare the two given values

**Testing HTML text**

```js
import { renderComponent, expect } from '../test_helper';
import App from '../../src/components/app';

describe('App', () => {
  it('shows the correct text', () => {
    //create an instance of App
    const component = renderComponent(App);

    expect(component).to.contain('React simple starter');
  });
});
```

**Testing HTML elements and classNames**

```js
describe('CommentBox', () => {
    //initialize component === CommentBox
    let component;

    beforeEach(() => { //runs before each 'it' helper
        component = renderComponent(CommentBox);//fresh instance of CommentBox
    });

    it('has a text area', () => {
        //using jquery selectors
        expect(component.find('textarea')).to.exist;
    });

    it('has a button', () => {
        expect(component.find('button')).to.exist;
    });

    it('has class name "comment-box"', () => {
        //component refers to the top-level div
        expect(component).to.have.class('comment-box');
    });
});
```

**Testing Events**

```js
describe('entering some text', () => {
    beforeEach(() => {
        //simulates fake events
        component.find('textarea').simulate('change', 'new comment');
    });

    it('shows text that in the textarea', () => {
        expect(component.find('textarea')).to.have.value('new comment');
    });

    it('when submitted, clears the input', () => {
        //component is the form
        component.simulate('submit');
        expect(component.find('textarea')).to.have.value('');
    });
});
```

- implementation

```js
'use strict';

import React, { Component } from 'react';

export default class CommentBox extends Component {
    constructor(props) {
        super(props);

        this.state = { comment: '' };
    }

    handleChange(event) {
        this.setState({ comment: event.target.value });
    }

    handleSubmit(event) {
        event.preventDefault();
        this.setState({ comment: '' });
    }

    render() {
        return (
            <form onSubmit={this.handleSubmit.bind(this)} className="comment-box">
                <textarea
                    onChange={this.handleChange.bind(this)}
                    value={this.state.comment}/>
                <button action="submit">Submit Comment</button>
            </form>
        );
    }
}
```

- when testing action-creators there is no need for 'renderComponent'
- testing correct 'type' and correct 'payload'

```js
import { expect } from '../test_helper';
import { SAVE_COMMENT } from '../../src/actions/types';
import { saveComment } from '../../src/actions/index';

describe('Actions', () => {
    describe('saveComment', () => {
        it('has the correct type', () => {
            const action = saveComment();//invoke the action-creator will return obj with type prop
            expect(action.type).to.have.equal(SAVE_COMMENT);
        });

        it('has the correct payload', () => {
            const action = saveComment('new comment');
            expect(action.payload).to.equal('new comment');
        });
    });
});

```
---

**Mocha**
- something that loads and runs all the tests

**Chai**
- something to write the tests with
- helpers for asserting properties

2. **Setup testing environment to run like a browser in the command line.**
  - jsdom is an emulation of the browser in the commandline
  - ``import jsdom from 'jsdom';`` then setup fake dom so jQuery will know how to access the window object
  ```js
  import jsdom from 'jsdom';

  //setup testing envionment to run like a browser in the terminal
  //similar to window.document
  //setting up the fake browser
  global.document = jsdom.jsdom('<!doctype html><html><body><body/><hmtl/>'); //fake instance of the dom
  global.window = global.document.defaultView;
  ```
  - ``import jquery from 'jquery';`` then attach the fake dom to jquery ``const $ = jquery(global.window);``
  - import ReactDOM and TestUtils
  ```js
  import TestUtils from 'react-addons-test-utils';
  import ReactDOM from 'react-dom';
  ```
  - ``import { expect } from 'chai';``
  - create the renderComponent method and export it, as well as 'expect' from the chai lib.

  ```js
  //build 'renderComponent' helper that should render given react class
  function renderComponent(ComponentClass) {
    //create a component instance
    const componentInstance = TestUtils.renderIntoDocument(< ComponentClass/>);
    //getting access to html in component instance
    //then wrap a jquery element around it $.
    return $(ReactDOM.findDOMNode(componentInstance));
  }
  export { renderComponent, expect }
  ```
  - in the render component method, if the component is connected to redux, you need to wrap that component in the provider component and import all the helpers from the react-redux and redux libs and reducers directory

  ```js

  import { Provider } from 'react-redux';
  import { createStore } from 'redux';
  import reducers from '../src/reducers';
    //build 'renderComponent' helper that should render given react class
  function renderComponent(ComponentClass) {
    //create a component instance
    const componentInstance = TestUtils.renderIntoDocument(
      //pass in our reducers into the createStore method
      <Provider store={createStore(reducers)}>
        < ComponentClass/>
      </Provider>
    );
    //getting access to html in component instance
    //then wrap a jquery element around it $.
    return $(ReactDOM.findDOMNode(componentInstance));
  }
  ```
  - there are 3 parameters that can be passed on to renderComponent
  ```js
  //ComponentClass
  //Props - any props that should be placed directly on to the ComponentClass
  //State - any application level state that we want to inject to our redux store
  function renderComponent(ComponentClass, props, state) {
  const componentInstance = TestUtils.renderIntoDocument(
    <Provider store={createStore(reducers, state)}>
      < ComponentClass { ...props } /> //make all props available
    </Provider>
  );
  ```

  - setting up the event simulate helper

  ```js
  $.fn.simulate = function (eventName, value) { // .fn = $('div').simulate
    if (value) {
      this.val(value); //set value to value passed
    }
    TestUtils.Simulate[eventName](this[0]); //first element
  }
  ```

  - setting up chaiJquery

  ```js
  import chai, { expect } from 'chai';
  import chaiJquery from 'chai-jquery';
  //... skipped other helpers

  chaiJquery(chai, chai.util, $);

  ```

  **Final Test Helper File**

  ```js

  import React from 'react';
  import jsdom from 'jsdom';
  import jquery from 'jquery';
  import TestUtils from 'react-addons-test-utils';
  import ReactDOM from 'react-dom';
  import chai, { expect } from 'chai';
  import { Provider } from 'react-redux';
  import { createStore } from 'redux';
  import reducers from '../src/reducers';
  import chaiJquery from 'chai-jquery';

  //setup testing envionment to run like a browser in the terminal
  //similar to window.document
  //setting up the fake browser
  global.document = jsdom.jsdom('<!doctype html><html><body><body/><hmtl/>');
  global.window = global.document.defaultView;
  const $ = jquery(global.window);

  //build 'renderComponent' helper that should render given react class
  function renderComponent(ComponentClass, props, state) {
    //create a component instance
    const componentInstance = TestUtils.renderIntoDocument(
      //pass in our reducers into the createStore method
      <Provider store={createStore(reducers, state)}>
        < ComponentClass { ...props } />
      </Provider>
    );
    //getting access to html in component instance
    //then wrap a jquery element around it $.
    return $(ReactDOM.findDOMNode(componentInstance));
  }

  $.fn.simulate = function (eventName, value) { // .fn = $('div').simulate
    if (value) {
      this.val(value);
    }

    TestUtils.Simulate[eventName](this[0]); //first element
  }

  //setting up chaiJquery
  chaiJquery(chai, chai.util, $);


  export { renderComponent, expect }
  ```
---

2. Higher Order Components
  - The ``connect(mapStateToProps)(component)`` is a higher order component that is specifically made to make communication with the provider at the top of the application
  - The ``<Provider />`` component wraps the redux store, the object that holds the global application state formed by all the reducers
    - watches the redux store, and is informed when there is a change, then it updates all the child component with the ``connect`` helper

  - authenticated routes

  ```js
  import requireAuth from './components/require_auth';
  //... stuff here
  <Provider store={createStoreWithMiddleware(reducers)}>
    <Router history={browserHistory}>
      <Route path="/" component={App}>
        <Route path="resources" component={requireAuth(Resources)} />
      </Route>
    </Router>
  </Provider>
  ```

  - create a higher order component that will check weather or not user is signed in

  ```js
    'use strict';

    import React, { Component } from 'react';
    import { connect } from 'react-redux';
    import { browserHistory } from 'react-router';

    export default function (ComposedComponent) {
        class Authentication extends Component {

            static contextTypes = {
                router: React.PropTypes.object
            }

            componentWillMount() {
                if (!this.props.authenticated) {
                    this.context.router.push('/');
                }
            }

            componentWillUpdate(nextProps) {
                if (!nextProps.authenticated) {
                    this.context.router.push('/');
                }
            }

            render () {
                return <ComposedComponent {...this.props}/>
            }
        }

        function mapStateToProps(state) {
            return {
                authenticated: state.authenticated
            }
        }

        return connect(mapStateToProps)(Authentication);
    }
  ```

  3. Middleware
  - handling promises with by making 'Async' middleware

  ```js
    export default function ({ dispatch }) {
        return next => action => {
            //check if no payload or not a promise, just skip.
            if (!action.payload || !action.payload.then) {
                return next(action); //goes to the next middleware
            }

            action.payload
                .then(response => {
                    //create a new action with same type
                    //except replace the payload
                    const newAction = { ...action, payload: response };
                    //run the entire action all over again
                    dispatch(newAction);
                });
        };
    }
  ```

4. Authentication
  - check authentication directory
  - too lengthy.
